#!/usr/bin/env python

import argparse
import glob
import json
import os
import shlex
import subprocess

from datetime import datetime


class Color(object):
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


def noop_build(file):
    return file


def c_build(file):
    bin_file = file.replace(".", "_")
    shell_out(f"gcc -o {bin_file} {file}")
    return bin_file


def c_cmd(file):
    return f"./{file}"


def golang_build(file):
    bin_file = file.replace(".", "_")
    shell_out(f"go build -o {bin_file} {file}")
    return bin_file


def golang_cmd(file):
    return f"./{file}"


def purge_class_files(base_dir):
    class_files = glob.glob(f"{base_dir}/*.class")
    if class_files:
        shell_out(f"rm {' '.join(class_files)}")


def java_build(file):
    def jar_class_arguments(base_dir, class_files):
        args = []
        for file in class_files:
            args.append(f"-C {base_dir} {file[len(base_dir) + 1:]}")
        return args

    base_dir = os.path.dirname(file)
    jar_file = file.replace(".java", ".jar")
    purge_class_files(base_dir)  # Clean up any class files left by Scala compilation
    shell_out(f"javac -sourcepath {base_dir} -classpath ./lib -d {base_dir} {file}")
    class_files = glob.glob(f"{base_dir}/*.class")
    lib_files = glob.glob("lib/**/*.class")
    if not class_files:
        raise Exception("No class files generated by javac")
    jar_classes = jar_class_arguments(base_dir, class_files) + jar_class_arguments(
        "lib", lib_files
    )
    shell_out(f"jar cfe {jar_file} Main {' '.join(jar_classes)}")
    purge_class_files(base_dir)  # Clean up our own class files
    return jar_file


def java_cmd(file):
    return f"java -jar {file}"


def lisp_cmd(file):
    return f"sbcl --script {file}"


def python_cmd(file):
    return f"python {file}"


def ruby_cmd(file):
    return f"ruby {file}"


def rust_build(file):
    bin_file = file.replace(".", "_")
    shell_out(f"rustc -o {bin_file} {file}")
    return bin_file


def rust_cmd(file):
    return f"./{file}"


def scala_build(file):
    base_dir = os.path.dirname(file)
    shell_out(f"scalac -d {base_dir} {file}")
    return base_dir


def scala_cmd(base_dir):
    return f"scala -classpath {base_dir} Main"


def typescript_build(file):
    shell_out(f"yarn tsc {file}")
    return file.replace(".ts", "")


def typescript_cmd(file):
    return f"node index.js ./{file}"


class LanguageConfig(object):
    def __init__(self, extension, cmd_fn, build_fn=noop_build, timing=True):
        self.extension = extension
        self.cmd_fn = cmd_fn
        self.build_fn = build_fn
        self.timing = timing


LANGUAGES = {
    "c": LanguageConfig("c", c_cmd, c_build, timing=False),
    "golang": LanguageConfig("go", golang_cmd, golang_build, timing=False),
    "java": LanguageConfig("java", java_cmd, java_build),
    "lisp": LanguageConfig("lisp", lisp_cmd, timing=False),
    "python": LanguageConfig("py", python_cmd),
    "ruby": LanguageConfig("rb", ruby_cmd),
    "rust": LanguageConfig("rs", rust_cmd, rust_build, timing=False),
    "scala": LanguageConfig("scala", scala_cmd, scala_build, timing=False),
    "typescript": LanguageConfig("ts", typescript_cmd, typescript_build),
}
language_list = ", ".join([l for l in LANGUAGES.keys()])


def find_files(args):
    languages = args.language if args.language else LANGUAGES.keys()
    for language in languages:
        if language not in LANGUAGES.keys():
            raise Exception(
                f"Unrecognized language: {language} (available: {language_list})"
            )
    if not os.path.isdir(args.year):
        raise Exception(f"Invalid year {args.year}")
    day = args.day.zfill(2)
    if not os.path.isdir(os.path.join(args.year, day)):
        raise Exception(f"Invalid day {args.day} for {args.year}")
    found = False
    for language in languages:
        filename = os.path.join(args.year, day, f"main.{LANGUAGES[language].extension}")
        if os.path.isfile(filename):
            found = True
            yield language, filename
        elif args.language:
            raise Exception(f"File for langage {language} does not exist: {filename}")
    if not found:
        raise Exception(f"No source files found in {os.path.join(args.year, day)}")


def output_file(args):
    day = args.day.zfill(2)
    return os.path.join(args.year, day, "output.txt")


def find_solution(filename):
    if os.path.isfile(filename):
        return "".join(open(filename, "r").readlines())
    else:
        return None


def shell_out(cmd):
    process = subprocess.Popen(
        shlex.split(cmd), stdout=subprocess.PIPE, universal_newlines=True
    )
    stdout = ""
    while True:
        stdout += process.stdout.readline()
        return_code = process.poll()
        if return_code is None:
            continue
        elif return_code > 0:
            print(stdout)
            raise Exception(f"Command '{cmd}' exited with status code {return_code}")
        else:
            stdout += process.stdout.readline()
        break
    return stdout


def format_decimal(number):
    parts = str(round(number, 2)).split(".")
    return ".".join([parts[0].rjust(3, " "), parts[1].rjust(2, "0")])


def format_duration(duration):
    if duration < 1:
        return f"{Color.OKGREEN}{format_decimal(duration * 1000)} ns{Color.ENDC}"
    elif duration < 1000:
        return f"{Color.OKCYAN}{format_decimal(duration)} Î¼s{Color.ENDC}"
    elif duration < 1000000:
        return f"{format_decimal(duration / 1000)} ms"
    else:
        return f"{Color.WARNING}{format_decimal(duration / 1000000)} s{Color.ENDC}"


def format_language(language):
    max = 0
    for l in LANGUAGES.keys():
        if len(l) > max:
            max = len(l)
    return language.ljust(max, " ")


def format_timing_info(timing_info, duration):
    duration_us = duration.seconds * 1000000 + duration.microseconds
    overhead = (
        duration_us
        - timing_info["part1"]["duration"]
        - timing_info["part2"]["duration"]
    )
    part1_avg_time = (
        timing_info["part1"]["duration"] / timing_info["part1"]["iterations"]
    )
    part2_avg_time = (
        timing_info["part2"]["duration"] / timing_info["part2"]["iterations"]
    )
    part2_spacer = " " if part1_avg_time >= 1000000 else ""
    overhead_spacer = " " if part2_avg_time >= 1000000 else ""
    return ", ".join(
        [
            f"part1: {format_duration(part1_avg_time)}",
            f"{part2_spacer}part2: {format_duration(part2_avg_time)}",
            f"{overhead_spacer}overhead: {format_duration(overhead)}",
        ]
    )


def solve(args):
    outfile = output_file(args)
    expected = find_solution(outfile)
    if expected and args.save:
        raise Exception(
            f"Cannot save results when {output_file(args)} alread exists, please delete it"
        )
    for language, filename in find_files(args):
        config = LANGUAGES[language]
        cmd = config.cmd_fn(config.build_fn(filename))
        actual = shell_out(cmd)
        if expected:
            day_language = (
                f"{args.year}/{args.day.rjust(2, '0')} {format_language(language)}"
            )
            if actual == expected:
                if config.timing:
                    start_time = datetime.now()
                    timing_info = json.loads(shell_out(f"{cmd} --time"))
                    duration = datetime.now() - start_time
                    print(
                        f"PASS [{day_language}] ({format_timing_info(timing_info, duration)})"
                    )
                else:
                    print(f"PASS [{day_language}]")
            else:
                print(f"{Color.FAIL}FAIL [{day_language}]{Color.ENDC}")
                print("Expected:")
                print(expected)
                print("Actual:")
                print(actual)
        else:
            print(actual.rstrip())
            if args.save:
                open(outfile, "w").write(actual)
                print(f"Saved reault to {outfile}")


current_day = datetime.utcnow()
parser = argparse.ArgumentParser(
    description=(
        "Run Advent of Code solution for a given year/day in the chosen language"
    )
)

default_year = os.environ.get("YEAR", current_day.year)
parser.add_argument(
    "-y",
    "--year",
    help=f"competition year (default: {default_year})",
    default=default_year,
)

default_day = os.environ.get("DAY", current_day.day)
parser.add_argument(
    "-d",
    "--day",
    help=f"competition day (default: {default_day})",
    default=default_day,
)

default_language = os.environ.get("LANGUAGE")
if default_language:
    language_helper = f"default: {default_language}"
else:
    language_helper = f"available languages: {language_list}"
parser.add_argument(
    "-l",
    "--language",
    nargs="+",
    help=f"programming language of the solution to run ({language_helper})",
    default=default_language,
)
parser.add_argument(
    "--save", help=f"save the programs output to output.txt", action="store_true"
)

args = parser.parse_args()

try:
    solve(args)
except Exception as e:
    print(e)
