#!/usr/bin/env python

import argparse
import glob
import os
import shlex
import subprocess
import timeit

from datetime import datetime

TIMING_ITERATIONS = 10


def noop_build(file):
    return file


def c_build(file):
    bin_file = file.replace(".", "_")
    shell_out(f"gcc -o {bin_file} {file}")
    return bin_file


def c_cmd(file):
    return f"./{file}"


def golang_build(file):
    bin_file = file.replace(".", "_")
    shell_out(f"go build -o {bin_file} {file}")
    return bin_file


def golang_cmd(file):
    return f"./{file}"


def java_build(file):
    def jar_class_arguments(base_dir, class_files):
        args = []
        for file in class_files:
            args.append(f"-C {base_dir} {os.path.basename(file)}")
        return " ".join(args)

    base_dir = os.path.dirname(file)
    jar_file = file.replace(".java", ".jar")
    shell_out(f"javac -sourcepath {base_dir} -d {base_dir} {file}")
    class_files = glob.glob(f"{base_dir}/*.class")
    if not class_files:
        raise Exception("No class files generated by javac")
    shell_out(f"jar cfe {jar_file} Main {jar_class_arguments(base_dir, class_files)}")
    shell_out(f"rm {' '.join(class_files)}")
    return jar_file


def java_cmd(file):
    return f"java -jar {file}"


def lisp_cmd(file):
    return f"sbcl --script {file}"


def python_cmd(file):
    return f"python {file}"


def ruby_cmd(file):
    return f"ruby {file}"


def rust_build(file):
    bin_file = file.replace(".", "_")
    shell_out(f"rustc -o {bin_file} {file}")
    return bin_file


def rust_cmd(file):
    return f"./{file}"


def scala_cmd(file):
    return f"scala {file}"


def typescript_build(file):
    shell_out(f"yarn tsc {file}")
    return file.replace(".ts", "")


def typescript_cmd(file):
    return f"node index.js ./{file}"


class LanguageConfig(object):
    def __init__(self, extension, cmd_fn, build_fn=noop_build):
        self.extension = extension
        self.cmd_fn = cmd_fn
        self.build_fn = build_fn


LANGUAGES = {
    "c": LanguageConfig("c", c_cmd, c_build),
    "golang": LanguageConfig("go", golang_cmd, golang_build),
    "java": LanguageConfig("java", java_cmd, java_build),
    "lisp": LanguageConfig("lisp", lisp_cmd),
    "python": LanguageConfig("py", python_cmd),
    "ruby": LanguageConfig("rb", ruby_cmd),
    "rust": LanguageConfig("rs", rust_cmd, rust_build),
    "scala": LanguageConfig("scala", scala_cmd),
    "typescript": LanguageConfig("ts", typescript_cmd, typescript_build),
}
language_list = ", ".join([l for l in LANGUAGES.keys()])


def find_files(args):
    languages = args.language if args.language else LANGUAGES.keys()
    for language in languages:
        if language not in LANGUAGES.keys():
            raise Exception(
                f"Unrecognized language: {language} (available: {language_list})"
            )
    if not os.path.isdir(args.year):
        raise Exception(f"Invalid year {args.year}")
    day = args.day.zfill(2)
    if not os.path.isdir(os.path.join(args.year, day)):
        raise Exception(f"Invalid day {args.day} for {args.year}")
    found = False
    for language in languages:
        filename = os.path.join(args.year, day, f"main.{LANGUAGES[language].extension}")
        if os.path.isfile(filename):
            found = True
            yield language, filename
        elif args.language:
            raise Exception(f"File for langage {language} does not exist: {filename}")
    if not found:
        raise Exception(f"No source files found in {os.path.join(args.year, day)}")


def output_file(args):
    day = args.day.zfill(2)
    return os.path.join(args.year, day, "output.txt")


def find_solution(filename):
    if os.path.isfile(filename):
        return "".join(open(filename, "r").readlines())
    else:
        return None


def shell_out(cmd):
    process = subprocess.Popen(
        shlex.split(cmd), stdout=subprocess.PIPE, universal_newlines=True
    )
    stdout = ""
    while True:
        stdout += process.stdout.readline()
        return_code = process.poll()
        if return_code is None:
            continue
        elif return_code > 0:
            print(stdout)
            raise Exception(f"Command '{cmd}' exited with status code {return_code}")
        else:
            stdout += process.stdout.readline()
        break
    return stdout


def solve(args):
    outfile = output_file(args)
    expected = find_solution(outfile)
    if expected and args.save:
        raise Exception(
            f"Cannot save results when {output_file(args)} alread exists, please delete it"
        )
    for language, filename in find_files(args):
        config = LANGUAGES[language]
        cmd = config.cmd_fn(config.build_fn(filename))
        actual = shell_out(cmd)
        if expected:
            if actual == expected:
                running_time = timeit.timeit(
                    lambda: shell_out(cmd), number=TIMING_ITERATIONS
                )
                print(f"PASS ({language}, {running_time / TIMING_ITERATIONS})")
            else:
                print(f"FAIL ({language})")
                print("Expected:")
                print(expected)
                print("Actual:")
                print(actual)
        else:
            print(actual.rstrip())
            if args.save:
                open(outfile, "w").write(actual)
                print(f"Saved reault to {outfile}")


current_day = datetime.utcnow()
parser = argparse.ArgumentParser(
    description=(
        "Run Advent of Code solution for a given year/day in the chosen language"
    )
)

default_year = os.environ.get("YEAR", current_day.year)
parser.add_argument(
    "-y",
    "--year",
    help=f"competition year (default: {default_year})",
    default=default_year,
)

default_day = os.environ.get("DAY", current_day.day)
parser.add_argument(
    "-d",
    "--day",
    help=f"competition day (default: {default_day})",
    default=default_day,
)

default_language = os.environ.get("LANGUAGE")
if default_language:
    language_helper = f"default: {default_language}"
else:
    language_helper = f"available languages: {language_list}"
parser.add_argument(
    "-l",
    "--language",
    nargs="+",
    help=f"programming language of the solution to run ({language_helper})",
    default=default_language,
)
parser.add_argument(
    "--save", help=f"save the programs output to output.txt", action="store_true"
)

args = parser.parse_args()

try:
    solve(args)
except Exception as e:
    print(e)
