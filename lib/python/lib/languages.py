import glob
import os


class Commands(object):
    def __init__(self, exec):
        self.compiler = []
        self.exec = exec
        self.time = f"{exec} --time"

    def add_compiler_command(self, command):
        self.compiler.append(command)


def c_cmds(file):
    bin_file = file.replace(".", "_")
    cmds = Commands(f"./{bin_file}")
    lib_files = glob.glob("lib/*.c")
    cmds.add_compiler_command(f"gcc -O3 -o {bin_file} {file} {' '.join(lib_files)}")
    return cmds


def golang_cmds(file):
    bin_file = file.replace(".", "_")
    cmds = Commands(f"./{bin_file}")
    cmds.add_compiler_command(f"go build -o {bin_file} {file}")
    return cmds


def java_cmds(file):
    def jar_class_arguments(base_dir, class_files):
        args = []
        for file in class_files:
            args.append(f"-C {base_dir} {file[len(base_dir) + 1:]}")
        return args

    base_dir = os.path.dirname(file)

    def purge_class_files():
        base_dir = os.path.dirname(file)
        class_files = glob.glob(f"{base_dir}/*.class")
        if class_files:
            return f"rm {' '.join(class_files)}"
        else:
            return "echo"

    jar_file = file.replace(".java", ".jar")

    def build_jar():
        lib_files = glob.glob("lib/**/*.class")
        class_files = glob.glob(f"{base_dir}/*.class")
        if not class_files:
            raise Exception("No class files generated by javac")
        jar_classes = jar_class_arguments(base_dir, class_files) + jar_class_arguments(
            "lib", lib_files
        )
        return f"jar cfe {jar_file} Main {' '.join(jar_classes)}"

    cmds = Commands(f"java -jar {jar_file}")
    cmds.add_compiler_command(purge_class_files)
    cmds.add_compiler_command(
        f"javac -sourcepath {base_dir} -classpath ./lib -d {base_dir} {file}"
    )
    cmds.add_compiler_command(build_jar)
    cmds.add_compiler_command(purge_class_files)
    return cmds


def lisp_cmds(file):
    return Commands(f"sbcl --script {file}")


def python_cmds(file):
    return Commands(f"python {file}")


def ruby_cmds(file):
    return Commands(f"ruby {file}")


def rust_cmds(file):
    bin_file = file.replace(".", "_")
    cmds = Commands(f"./{bin_file}")
    cmds.add_compiler_command(f"rustc -C opt-level=3 -o {bin_file} {file} -L ./lib")
    return cmds


def scala_cmds(file):
    base_dir = os.path.dirname(file)
    cmds = Commands(f"scala -optimize -classpath {base_dir}:./lib Main")
    cmds.add_compiler_command(f"scalac -d {base_dir} -classpath ./lib {file}")
    return cmds


def typescript_cmds(file):
    js_file = file.replace(".ts", "")

    # node writes errors to stdout
    # @see https://github.com/microsoft/TypeScript/issues/615
    cmds = Commands(f"node index.js ./{js_file}")
    cmds.add_compiler_command(f"yarn tsc {file}")
    return cmds


class LanguageConfig(object):
    def __init__(self, extension, commands, timing=True):
        self.extension = extension
        self.commands = commands
        self.timing = timing


LANGUAGES = {
    "c": LanguageConfig("c", c_cmds),
    "golang": LanguageConfig("go", golang_cmds, timing=False),
    "java": LanguageConfig("java", java_cmds),
    "lisp": LanguageConfig("lisp", lisp_cmds, timing=False),
    "python": LanguageConfig("py", python_cmds),
    "ruby": LanguageConfig("rb", ruby_cmds),
    "rust": LanguageConfig("rs", rust_cmds),
    "scala": LanguageConfig("scala", scala_cmds),
    "typescript": LanguageConfig("ts", typescript_cmds),
}


def language_config(language):
    if language in LANGUAGES:
        return LANGUAGES[language]
    else:
        raise Exception(f"Unknown language {language}")


def all_languages():
    return [l for l in LANGUAGES.keys()]
